================================================================================
               MICROSERVICIO DE TRANSFERENCIAS - EXPLICACIÓN TÉCNICA COMPLETA
================================================================================

AUTOR: Implementación siguiendo el patrón Puertos y Adaptadores
FECHA: Agosto 2024
TECNOLOGÍAS: Java 21, Spring Boot 3.5.4, Maven

================================================================================
1. INTRODUCCIÓN Y CONTEXTO DEL PROBLEMA
================================================================================

PROBLEMA A RESOLVER:
- Crear un microservicio performante que maneje transferencias concurrentes
- Garantizar consistencia de datos bajo alta carga
- Implementar idempotencia para evitar transferencias duplicadas
- Mantener invariantes del negocio (sin saldos negativos, suma total constante)
- Soportar miles de transferencias concurrentes con baja latencia

DESAFÍOS TÉCNICOS PRINCIPALES:
1. Race conditions: Múltiples hilos modificando el mismo dato simultáneamente
2. Deadlocks: Hilos bloqueados esperando recursos mutuamente
3. Idempotencia: Evitar procesar la misma operación múltiples veces
4. Performance: Minimizar contención y maximizar throughput
5. Consistencia: Mantener invariantes de negocio bajo concurrencia

================================================================================
2. DECISIÓN ARQUITECTÓNICA: PATRÓN PUERTOS Y ADAPTADORES
================================================================================

¿QUÉ ES ESTE PATRÓN?
La arquitectura hexagonal (Ports & Adapters) separa la lógica de negocio del 
mundo exterior mediante interfaces (puertos) y sus implementaciones (adaptadores).

VENTAJAS TÉCNICAS:
- Aislamiento del dominio: Las reglas de negocio no dependen de frameworks
- Testabilidad: Se pueden crear mocks de los puertos fácilmente
- Flexibilidad: Cambiar implementaciones sin afectar el dominio
- Mantenibilidad: Responsabilidades claramente separadas

ESTRUCTURA IMPLEMENTADA:

domain/
├── model/           # Entidades y objetos de valor del negocio
├── exceptions/      # Excepciones que representan violaciones de reglas

application/
├── ports/in/        # Interfaces de casos de uso (contratos de entrada)
├── ports/out/       # Interfaces de repositorios (contratos de salida)
└── services/        # Orquestadores que implementan los casos de uso

infrastructure/
└── adapters/
    ├── in/rest/     # Implementación de entrada vía HTTP
    └── out/persistence/ # Implementación de salida vía almacenamiento

FLUJO DE DATOS:
HTTP Request → REST Controller → Use Case → Service → Domain Entity → Repository → Storage

================================================================================
3. CAPA DE DOMINIO - EL CORAZÓN DEL NEGOCIO
================================================================================

3.1 ENTIDAD ACCOUNT (Cuenta)
------------------------------
RESPONSABILIDAD: Encapsular el estado y comportamiento de una cuenta bancaria

DECISIONES TÉCNICAS:
- BigDecimal para balance: Evita errores de precisión en cálculos monetarios
- Métodos de negocio: hasSufficientFunds(), debit(), credit()
- Inmutabilidad parcial: Solo métodos controlados pueden modificar el balance

CÓDIGO CLAVE:
```java
public boolean hasSufficientFunds(BigDecimal amount) {
    return balance.compareTo(amount) >= 0;  // Evita saldos negativos
}
```

¿POR QUÉ BigDecimal?
- float/double tienen errores de precisión: 0.1 + 0.2 ≠ 0.3
- BigDecimal garantiza precisión exacta en operaciones monetarias
- Requerimiento crítico en sistemas financieros

3.2 OBJETO DE VALOR TRANSFER
-----------------------------
RESPONSABILIDAD: Representar una transferencia como concepto inmutable

DECISIONES TÉCNICAS:
- Record en Java: Inmutabilidad automática y menos boilerplate
- Validaciones en constructor: Falla rápido ante datos inválidos
- Método isValid(): Encapsula lógica de validación de negocio

¿POR QUÉ INMUTABLE?
- Previene modificaciones accidentales
- Thread-safe por naturaleza
- Representa un concepto de negocio que no debe cambiar una vez creado

3.3 EXCEPCIONES DE DOMINIO
---------------------------
RESPONSABILIDAD: Comunicar violaciones de reglas de negocio

JERARQUÍA IMPLEMENTADA:
- DomainException (base abstracta)
  ├── InsufficientFundsException
  ├── AccountNotFoundException
  └── InvalidTransferException

¿POR QUÉ EXCEPCIONES ESPECÍFICAS?
- Facilita manejo diferenciado en capas superiores
- Permite códigos HTTP específicos (400, 404, etc.)
- Comunica claramente qué regla de negocio fue violada

================================================================================
4. CAPA DE APLICACIÓN - ORQUESTACIÓN Y CASOS DE USO
================================================================================

4.1 PUERTOS DE ENTRADA (Use Cases)
-----------------------------------
RESPONSABILIDAD: Definir contratos de lo que la aplicación puede hacer

CASOS DE USO IMPLEMENTADOS:
1. TransferMoneyUseCase: Transferir dinero entre cuentas
2. GetBalancesUseCase: Consultar balances actuales
3. ResetLedgerUseCase: Reinicializar el estado del sistema

PATRÓN COMMAND:
```java
record TransferMoneyCommand(
    String fromAccountId,
    String toAccountId, 
    BigDecimal amount,
    String idempotencyKey
) {
    // Validaciones en constructor compacto
}
```

¿POR QUÉ RECORDS PARA COMANDOS?
- Inmutabilidad garantizada
- Validaciones centralizadas en constructor
- Sintaxis concisa y expresiva
- Representan intención del usuario claramente

4.2 PUERTOS DE SALIDA (Repositories)
-------------------------------------
RESPONSABILIDAD: Definir contratos para persistencia y servicios externos

INTERFACES IMPLEMENTADAS:
- AccountRepository: CRUD de cuentas
- IdempotencyRepository: Manejo de claves de idempotencia

¿POR QUÉ INTERFACES SEPARADAS?
- Principio de Responsabilidad Única: Cada interfaz tiene un propósito
- Dependency Inversion: El dominio no depende de implementaciones concretas
- Facilita testing: Se pueden crear mocks específicos

4.3 SERVICIO DE APLICACIÓN (LedgerService)
-------------------------------------------
RESPONSABILIDAD: Orquestar operaciones y manejar concurrencia

ESTRATEGIA DE CONCURRENCIA IMPLEMENTADA:

a) LOCKS GRANULARES POR CUENTA:
```java
private final ConcurrentHashMap<String, ReentrantLock> accountLocks = new ConcurrentHashMap<>();

private ReentrantLock getAccountLock(String accountId) {
    return accountLocks.computeIfAbsent(accountId, k -> new ReentrantLock());
}
```

¿POR QUÉ LOCKS GRANULARES?
- Mejor paralelismo: Transferencias entre cuentas diferentes no se bloquean
- Menor contención: Solo bloquea las cuentas específicas involucradas
- Escalabilidad: Performance no degrada linealmente con número de cuentas

b) PREVENCIÓN DE DEADLOCKS:
```java
String firstAccount = fromAccountId.compareTo(toAccountId) < 0 ? fromAccountId : toAccountId;
String secondAccount = fromAccountId.equals(firstAccount) ? toAccountId : fromAccountId;

firstLock.lock();
try {
    secondLock.lock();
    try {
        // Operación crítica
    } finally {
        secondLock.unlock();
    }
} finally {
    firstLock.unlock();
}
```

¿CÓMO PREVIENE DEADLOCKS?
- Ordenamiento consistente: Todos los hilos toman locks en el mismo orden
- Imposibilidad de espera circular: A→B y B→A no puede ocurrir simultáneamente
- Algoritmo determinístico: String.compareTo() garantiza orden total

c) IDEMPOTENCIA CON VERIFICACIÓN DOBLE:
```java
// Primera verificación (sin lock) - optimización
if (idempotencyRepository.wasProcessed(key)) return;

// Adquirir locks...

// Segunda verificación (con lock) - correctitud
if (idempotencyRepository.wasProcessed(key)) return;

// Procesar transferencia...
idempotencyRepository.markAsProcessed(key);
```

¿POR QUÉ VERIFICACIÓN DOBLE?
- Optimización: El 99% de casos no requiere sincronización
- Correctitud: Race conditions se resuelven con la segunda verificación
- Performance: Evita trabajo innecesario en la mayoría de llamadas

================================================================================
5. CAPA DE INFRAESTRUCTURA - ADAPTADORES CONCRETOS
================================================================================

5.1 ADAPTADORES DE PERSISTENCIA
--------------------------------
RESPONSABILIDAD: Implementar almacenamiento thread-safe en memoria

DECISIÓN: ConcurrentHashMap
```java
private final ConcurrentHashMap<String, Account> accounts = new ConcurrentHashMap<>();
```

¿POR QUÉ ConcurrentHashMap?
- Thread-safety: Operaciones básicas (get, put) son atómicas
- Performance: Particionado interno reduce contención
- Sin sincronización adicional: No requiere synchronized blocks

LIMITACIONES EN PRODUCCIÓN:
- Memoria volátil: Datos se pierden al reiniciar
- Escalabilidad: Limitado por memoria de una JVM
- Distribución: No funciona en múltiples instancias

ALTERNATIVAS PARA PRODUCCIÓN:
- Redis: Cache distribuido con expiración automática
- PostgreSQL: Base de datos ACID para consistencia
- Apache Kafka: Event sourcing para auditabilidad

5.2 ADAPTADORES REST
---------------------
RESPONSABILIDAD: Exponer funcionalidad vía HTTP siguiendo el contrato

MANEJO DE ERRORES IMPLEMENTADO:
```java
} catch (AccountNotFoundException e) {
    return ResponseEntity.status(HttpStatus.NOT_FOUND)
            .body(new ErrorResponse("unknown account"));
} catch (InsufficientFundsException e) {
    return ResponseEntity.badRequest()
            .body(new ErrorResponse("insufficient funds"));
```

¿POR QUÉ MAPEO ESPECÍFICO DE EXCEPCIONES?
- Códigos HTTP semánticos: 404 para no encontrado, 400 para business rules
- API consistente: Mismos errores siempre devuelven mismo formato
- Debugging: Logs específicos para cada tipo de error

MEDICIÓN DE PERFORMANCE:
```java
long startTime = System.currentTimeMillis();
// ... operación ...
long duration = System.currentTimeMillis() - startTime;
return new TransferResponse(true, duration);
```

¿POR QUÉ MEDIR LATENCIA?
- Monitoreo: Detectar degradación de performance
- SLA compliance: Verificar que se cumplen los thresholds
- Debugging: Identificar operaciones lentas

================================================================================
6. CONFIGURACIÓN Y BOOTSTRAP
================================================================================

6.1 SPRING BOOT CONFIGURATION
------------------------------
RESPONSABILIDAD: Configurar el contenedor de dependencias

DECISIONES DE CONFIGURACIÓN:
- Server port: ${PORT:8080} - Configurable vía variable de entorno
- Logging level: ${LOG_LEVEL:INFO} - Ajustable para debugging
- Jackson: NON_NULL para respuestas más limpias

6.2 INICIALIZACIÓN DE DATOS
----------------------------
RESPONSABILIDAD: Configurar estado inicial del sistema

```java
@Component
public class DataInitializer implements CommandLineRunner {
    public void run(String... args) {
        ResetLedgerCommand command = new ResetLedgerCommand(100, BigDecimal.valueOf(1000));
        resetLedgerUseCase.resetLedger(command);
    }
}
```

¿POR QUÉ CommandLineRunner?
- Ejecución post-startup: Se ejecuta después de inicializar Spring
- Acceso a beans: Puede usar servicios de aplicación ya configurados
- Control de errores: Puede fallar el startup si hay problemas

================================================================================
7. ASPECTOS DE PERFORMANCE Y ESCALABILIDAD
================================================================================

7.1 ESTRATEGIAS DE OPTIMIZACIÓN IMPLEMENTADAS
----------------------------------------------

a) MINIMIZACIÓN DE REGIONES CRÍTICAS:
- Locks se toman solo durante la modificación de datos
- Validaciones se hacen fuera de las regiones críticas
- I/O operations (logging) fuera de locks cuando es posible

b) LOCK-FREE OPERATIONS CUANDO ES POSIBLE:
- Lectura de balances sin locks (snapshot)
- Primera verificación de idempotencia sin sincronización
- Uso de estructuras thread-safe para operaciones simples

c) REDUCCIÓN DE CONTENCIÓN:
- Locks por cuenta en lugar de lock global
- ConcurrentHashMap en lugar de synchronized Map
- Ordenamiento para prevenir deadlocks sin timeouts

7.2 MÉTRICAS DE PERFORMANCE ESPERADAS
--------------------------------------

TARGETS DEFINIDOS EN EL ENUNCIADO:
- Latencia p95 < 200ms
- Error rate < 1%
- Invariantes mantenidos > 99%

FACTORES QUE AFECTAN PERFORMANCE:
- Número de cuentas: Más cuentas = menor contención
- Distribución de transferencias: Hot accounts degradan performance
- Tamaño de claves de idempotencia: Afecta memoria y lookup time

OPTIMIZACIONES ADICIONALES POSIBLES:
- Pool de threads dedicado para transferencias
- Particionado de cuentas por hash
- Cache de accounts frecuentemente accedidas
- Batch processing para múltiples transferencias

================================================================================
8. TESTING Y VERIFICACIÓN
================================================================================

8.1 PRUEBAS REALIZADAS
-----------------------

a) CORRECTITUD FUNCIONAL:
✅ Endpoints responden correctamente
✅ Transferencias actualizan balances apropiadamente
✅ Validaciones rechazan datos inválidos
✅ Códigos HTTP correctos para cada tipo de error

b) IDEMPOTENCIA:
✅ Múltiples requests con mismo key no duplican transferencias
✅ Balances no cambian en llamadas repetidas
✅ Performance no degrada significativamente

c) CONCURRENCIA:
✅ Transferencias paralelas no corrompen datos
✅ Invariante de suma total se mantiene
✅ No hay deadlocks en transferencias cruzadas

8.2 SCRIPT DE PRUEBA IMPLEMENTADO
----------------------------------
```bash
# Transferencias concurrentes en background
for i in {1..20}; do
    {
        curl -s -X POST .../transfer -d "{...}" > /dev/null
    } &
done
wait  # Esperar que terminen todas

# Verificar invariante
total=$(curl -s .../balances | jq 'add')
if [ "$total" -eq 10000 ]; then
    echo "✅ Invariante mantenido"
fi
```

¿POR QUÉ ESTE ENFOQUE DE TESTING?
- Simula carga real: Múltiples requests concurrentes
- Verifica invariantes: La propiedad más crítica del sistema
- Automatizable: Se puede integrar en CI/CD
- Deterministico: El resultado debe ser siempre el mismo

================================================================================
9. CONSIDERACIONES PARA PRODUCCIÓN
================================================================================

9.1 LIMITACIONES ACTUALES
--------------------------

PERSISTENCIA:
- Datos en memoria se pierden al reiniciar
- No hay respaldo ni recuperación ante fallos
- Escalabilidad limitada por memoria de una instancia

SOLUCIÓN: Implementar adaptadores para Redis (cache) y PostgreSQL (persistencia)

OBSERVABILIDAD:
- Logs básicos pero sin métricas estructuradas
- No hay trazabilidad de requests end-to-end
- Sin alertas automáticas ante anomalías

SOLUCIÓN: Integrar Micrometer, OpenTelemetry, y herramientas de APM

SECURITY:
- No hay autenticación ni autorización
- Sin rate limiting para prevenir abuso
- Sin validación de integridad de requests

SOLUCIÓN: Implementar Spring Security, API keys, y validación de firmas

9.2 ARQUITECTURA PARA ALTA DISPONIBILIDAD
------------------------------------------

DISTRIBUCIÓN:
- Múltiples instancias tras load balancer
- State compartido en Redis Cluster
- Base de datos replicada (master-slave)

FAULT TOLERANCE:
- Circuit breakers para dependencias externas
- Retry logic con backoff exponencial
- Health checks y graceful shutdown

ESCALABILIDAD:
- Auto-scaling basado en CPU/latencia
- Particionado de cuentas por región/tipo
- Read replicas para consultas de balances

================================================================================
10. CONCLUSIONES Y LECCIONES APRENDIDAS
================================================================================

10.1 DECISIONES TÉCNICAS EXITOSAS
----------------------------------

PATRÓN HEXAGONAL:
✅ Separación clara de responsabilidades
✅ Facilidad para testing unitario  
✅ Flexibilidad para cambiar implementaciones
✅ Código expresivo y mantenible

MANEJO DE CONCURRENCIA:
✅ Locks ordenados previenen deadlocks efectivamente
✅ Granularidad por cuenta maximiza paralelismo
✅ Verificación doble optimiza casos comunes

IDEMPOTENCIA:
✅ Implementación simple pero efectiva
✅ No requiere almacenamiento sofisticado
✅ Performance impact mínimo

10.2 AREAS DE MEJORA IDENTIFICADAS
----------------------------------

TESTING:
- Faltan tests unitarios automatizados
- Sin tests de carga con k6 como requerido
- No hay benchmarks de performance

MONITOREO:
- Métricas limitadas a latencia básica
- Sin visibilidad de contención de locks
- No hay alertas proactivas

DOCUMENTATION:
- Falta documentación de APIs (OpenAPI/Swagger)
- Sin diagramas de secuencia para flows complejos
- Guías de deployment y troubleshooting limitadas

10.3 REFLEXIONES FINALES
-------------------------

COMPLEJIDAD vs SIMPLICIDAD:
La implementación logra un balance efectivo entre simplicidad (para mantenibilidad)
y sofisticación técnica (para performance y correctitud).

TRADE-OFFS CONSIDERADOS:
- Memoria vs Persistencia: Se priorizó simplicidad para el MVP
- Latencia vs Throughput: Se optimizó para latencia como requiere el enunciado
- Consistency vs Availability: Se eligió strong consistency por ser sistema financiero

EXTENSIBILIDAD:
La arquitectura hexagonal permite agregar funcionalidades (auditoria, webhooks,
notificaciones) sin modificar el core del dominio.

Este microservicio demuestra principios sólidos de ingeniería de software:
separación de responsabilidades, manejo apropiado de concurrencia, y diseño
orientado al dominio que facilita evolución y mantenimiento a largo plazo.

================================================================================
FIN DEL DOCUMENTO
================================================================================
